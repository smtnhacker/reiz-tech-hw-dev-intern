# Reiz Tech Homework

***By Ron Mikhael Surara***

My answers for the Reiz Tech Homework for the .NET developer intern position application.

## Item 1

**Problem Statement**

_Please write console app. User should be able to input hours and minutes of the analogue clock. Program must calculate lesser angle in degrees between hours arrow and minutes arrow and provide output in the console window._

**Solution Explanation**

For this problem, we are simply tasked with creating a console application that computes the lesser angle between the hands of an analogue clock. This is a simple task which only uses a short mathematical formula to solve.

To start off, we begin by reading the input from the console. To improve user experience, input prompts have been provided. The values are stored in variables `hours` and `minutes`, which are self explanatory. For the purpose of the problem, `hours` must only be in the range `[1, 12]` while minutes must only be in the range `[0, 59]`. These are converted to `float` since we will be dealing with Real numbers, instead of just integers.

```c#
Console.WriteLine("Please input current hour: ");
float hours = (float) Convert.ToInt32(Console.ReadLine());
Console.WriteLine("Please input current minute: ");
float minutes = (float) Convert.ToInt32(Console.ReadLine());
```

After obtaining the input, `hours` is normalized by encoding `12nn/12pm` to `0`. This simplifies plenty of calculations.

```c#
if (hours == 12)
{
    hours = 0;
}
```

It should be noted that the hour hand also moves every minute, not only every hour. Hence, we must consider the movement of the hour hand due to minutes. This is simply the conversion of minutes into hours (e.g., 30 min is 0.5 hours)

```c#
hours += minutes / 60;
```

To compute for the angle, we should first take note of the following:

- the hour hand moves $\frac{360^\circ}{12}=30^\circ$ every hour
- the minute hand moves $\frac{360^\circ}{60}=6^\circ$ every minute

```c#
const float HourRate = 360f / 12f;
const float MinuteRate = 360f / 60f;
```

The angle is just then the absolute value between the angle of the hour hand and the angle of the minute hand.

```c#
float angle = Math.Abs(HourRate * hours - MinuteRate * minutes);
```

Since we want the lesser angle, we should also compare the answer so far with its explementary angle and get the minimum of the two.

```c#
float ans = Math.Min(angle, 360 - angle);
```

Finally, we print the output on the console.

```c#
Console.WriteLine(String.Format("The angle is {0} deg.", ans));
```

**Solution Code**

The entire code is as follows:

```c#
// Take the user's input
Console.WriteLine("Please input current hour: ");
float hours = (float) Convert.ToInt32(Console.ReadLine());
Console.WriteLine("Please input current minute: ");
float minutes = (float) Convert.ToInt32(Console.ReadLine());

// Normalize hours
if (hours == 12)
{
    hours = 0;
}

// Consider the movement of the hour hand
// due to the movement of the minute hand
hours += minutes / 60;

// Define constants for clarity
const float HourRate = 360f / 12f;
const float MinuteRate = 360f / 60f;

// Compute the angle
float angle = Math.Abs(HourRate * hours - MinuteRate * minutes);

// Take the lesser angle
float ans = Math.Min(angle, 360 - angle);

// Finally, print the output
Console.WriteLine(String.Format("The angle is {0} deg.", ans));
```

## Item 2

**Problem Statement**

*Imagine we have a hierarchical structure:*

```c#
class Branch 
{
	List<Branch> branches;    
}
```

*Please write a program, where you would create similar structure. Pass this structure into your own created method and calculate the depth of provided structure. Main requirement to complete this task: use recursion.*

**Solution Explanation**

For this problem, we first define a class called `Branch`. It will be a recursive structure, so its member will be a list of other `Branches`. For brevity, we define a public method called `Add` that simply adds a new child branch to the element.

```c#
public class Branch
{
    public List<Branch> branches = new List<Branch>();

    public void Add(Branch branch)
    {
        branches.Add(branch);
    }
}
```

The example structure is then manually generated by creating eleven branches, one which would be assigned as the `root`.

```c#
List<Branch> branchList = new List<Branch>();
for(int i=0; i<10; i++)
{
     branchList.Add(new Branch());
}
Branch root = new Branch();
// manually add the branches
root.Add(branchList[0]);
root.Add(branchList[1]);
branchList[0].Add(branchList[2]);
branchList[1].Add(branchList[3]);
branchList[1].Add(branchList[4]);
branchList[1].Add(branchList[5]);
branchList[3].Add(branchList[6]);
branchList[4].Add(branchList[7]);
branchList[4].Add(branchList[8]);
branchList[7].Add(branchList[9]);
```

To compute for the structure's depth, we recursively check which child branch is the deepest. The depth of a certain subtree is then one plus its deepest child's depth.

```c#
private static int CalculateDepth(Branch node)
{
    int deepestBranch = 0;
    foreach(Branch child in node.branches)
    {
        deepestBranch = Math.Max(deepestBranch, CalculateDepth(child));
    }
    return 1 + deepestBranch;
}
```

Finally, the structure's depth is printed on the console.

```c#
Console.WriteLine(String.Format("Structure has depth {0}.", CalculateDepth(root)));
```

**Solution Code**

The complete code is as follows:

```c#
using System;

public class Branch
{
    public List<Branch> branches = new List<Branch>();

    public void Add(Branch branch)
    {
        branches.Add(branch);
    }
}

public class Program
{
    public static void Main()
    {
        List<Branch> branchList = new List<Branch>();
        for(int i=0; i<10; i++)
        {
            branchList.Add(new Branch());
        }

        Branch root = new Branch();

        // manually add the branches
        root.Add(branchList[0]);
        root.Add(branchList[1]);
        branchList[0].Add(branchList[2]);
        branchList[1].Add(branchList[3]);
        branchList[1].Add(branchList[4]);
        branchList[1].Add(branchList[5]);
        branchList[3].Add(branchList[6]);
        branchList[4].Add(branchList[7]);
        branchList[4].Add(branchList[8]);
        branchList[7].Add(branchList[9]);

        Console.WriteLine(String.Format("Structure has depth {0}.", CalculateDepth(root)));
    }

    private static int CalculateDepth(Branch node)
    {
        int deepestBranch = 0;
        foreach(Branch child in node.branches)
        {
            deepestBranch = Math.Max(deepestBranch, CalculateDepth(child));
        }
        return 1 + deepestBranch;
    }

}
```

